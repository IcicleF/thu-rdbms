# Indexing 文档

接口和功能大量地借鉴了 Stanford 课程网站上给出的接口示例。

## IXManager

`IXManager` 负责管理索引文件，它的实现原理和记录管理部分的 `RMManager` 是完全类似的。

Stanford 课程官网中，`createIndex` 和 `openIndex` 支持指定一个索引编号。我们在实现时照搬了这一设定，但之后的流程中，如果存在多个索引，我们怀疑可能会出现某些索引失效的问题。

* 对此，我们现阶段不打算考虑此事。如果问题的确存在，我们会规定一个表只支持一个簇集索引。

我们提供 `createIndex`、`openIndex`、`closeIndex` 三个接口来创建、打开和关闭一个索引文件。接口原型与 Stanford 课程官网给出的基本相同。

## IXHandler

`IXHandler` 负责插入、删除和检索索引。

`IXHandler` 几乎什么都不做，主要的任务都由 `BPlusTree` 类完成。`IXManager` 负责创建和初始化一个 `BPlusTree` 实例；`IXHandler` 接受这个实例，并且准备好比较两个索引值的函数（一个`std::function<int(void*, void*)>`实例）供 `BPlusTree` 调用。

## IXScanner

`IXScanner` 接受一个比较条件，通过 `IXHandler` 遍历 B+ 树。

`IXScanner` 的实现与 `RMScanner` 是类似的，不同的是查找方式变成了树上查找。

## BPlusTree

`BPlusTree` 是一棵并不完美的 B+ 树。

`BPlusTree` 中，记录的索引值**不能重复**；另外，`BPlusTree` 在插入时不进行旋转。除去这两点之外，`BPlusTree` 是一棵正常的 B+ 树。

### 文件组织结构

`BPlusTree` 直接工作在一个打开的 `BufPageManager` 上。

我们利用第 0 页存储一些元信息，第 1 页开始每页存储一个 B+ 树节点。

第 0 页目前只有 12 个字节有用。这 12 个字节的使用方式如下：

* `attrLen` (0~1)：索引值的长度；
  * 基于实现上的考量，如果应用中被索引的主键是一个 `VARCHAR`，我们无法为这个 `VARCHAR` 开出变长空间，而只能取它的最大长度作为索引值的长度。
* `attrType` (2~3)：索引类型；
* `nodeNum` (4~7)：总结点数；
* `root` (8~11)：根节点的页号。

从第 1 页开始是 B+ 树节点，组织方式如下：

* `count` (0~1)：节点中的记录数；
* `type` (2~3)：节点的属性（内部节点或叶节点）；
* `parent` (4~7)：父结点；
* `parentPtr` (8~9)：**未被使用。**本意是希望维护父结点的第几个指针指向当前节点，但若要维护这一属性，增删时代价过大(插入记录时需要更新后面的每个孩子)；因此现在不予维护，这 2 个字节也不被使用。
* 10~8191：以指针 0 → 索引值 0 → 指针 1 → 索引值 1 → …… → 指针 n-1 → 索引值 n-1 → 指针 n 的顺序连续存储。每个指针占用 6 字节，索引值占用 attrLen 字节。
* 残余的空间被废弃。

内部节点使用指针域的前 4 个字节存储一个页号，后 2 个字节不使用。叶节点使用 0 ~ n-1 的指针存储一个 RID (page 4 字节 + slot 2 字节)，第 n 个指针存储一个页号（用来连接所有叶子形成单向链表）。

### 基本操作

检索、插入和删除都在 `BPlusTree` 中完整实现，另外还提供函数用于广度优先搜索整棵 B+ 树，方便 debug。

详细的实现不再赘述。