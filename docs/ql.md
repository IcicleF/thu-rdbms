# Query 文档

本阶段我们同样没有参考 Stanford 的课程，而是完全自行实现。

在这个过程中，我们发现前两阶段有些接口多余，有些接口的形式相当不友好，但迫于时间无法进一步修改。

本阶段我们主要完成了两项工作：`QLManager` 和 `whereCheck`。

## QLManager

QLManager 接管 `INSERT`、`DELETE`、`UPDATE` 和 `SELECT` 四大语句。

### INSERT, DELETE 和 UPDATE

这三个语句只涉及单表的修改。

#### INSERT

利用主键构成的索引检验主键重复。如果没有重复，逐条插入记录。

#### DELETE

顺次枚举所有记录检查是否符合规则，是则删除。

#### UPDATE

顺次枚举所有记录检查是否符合规则，记录符合规则的记录数量。如果它大于 1 并且涉及对主键的修改，则报错；否则修改这些记录。

### SELECT

`SELECT` 涉及多表查询。计算多表的自然连接并不难，但耗费大量的空间。我们使用一个递归过程顺次枚举每张表中的每条记录，检查这些行的组合是否满足规则。如果是，利用一个回调过程把它们整理成一行输出。

## whereCheck

`whereCheck` 接受一个 `AstWhereClause` 指针，和一个表名到行的映射。

函数在执行时计算表达式的值，判断 `WHERE` 从句逻辑运算在某一个特定的行的组合上的结果并返回布尔值。`whereCheck` 有能力判断对两个不相容类型的比较操作，在出现这种情况时扔出异常。

关于不相容类型的说明：

* `INT`、`FLOAT` 与其他类型不相容
* `DATE` 与其他类型不相容，除非是一个长度为 10 并且符合日期格式的 `STRING` 常量

## Info

info.h 中封装了表示元信息的类，使得我们访问元信息时不需要每次都读文件。

## 自增编号

我们的记录物理上无序存储。为了保证后插入的数据始终出现在先插入的数据后面，我们对每张表维护一个默认索引，索引值表示这是这张表创建以来第几个插入的记录。

这个值只增不减，可以确保唯一性。遍历表时按照默认索引遍历，可以保证按照插入的先后顺序访问每条记录。

这个值只作索引用，所以无需存储在记录中。