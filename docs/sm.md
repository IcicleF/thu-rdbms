# System Management 文档

本阶段我们较早地开始了工作，同时也因为 Stanford 的 RedBase 项目中词法和语法分析器是预先给出的，学生无需自行编写，因此这部分我们完全没有参考 Stanford 的接口，全部自行设计和实现。

## AST

我们使用 Flex/Bison 建立了一个词法和语法分析器，支持大作业文法规则文档上给出的所有文法，额外支持浮点数、加减运算和在 WHERE 从句中使用 OR, NOT 关键字。

我们利用 Bison 生成一棵抽象语法树，抽象语法树的实现基本参考了编译原理课程，呈现为 AST 节点基类 `AstBase` 和一系列分别代表不同语法结构的它的子类。每个 `AstBase` 的子类的实例保存它的类型，需要时根据这个类型进行动态类型转换获取子类实例。

`AstBase` 及其子类的各个成员函数中，`checkSemantic` 用来执行语义检查；`printTree` 用来打印抽象语法树；`eval` 用来执行语句，我们利用了 C++ 17 的新特性 `any` 来一定程度上减少这个函数的编程复杂度。

## MetaManager

这一阶段，一切工作交由 `MetaManager` 类完成。`MetaManager` 是一个专门维护元信息的类，封装数据库、表和索引相关的所有元操作。

全部的数据库位于 `database` 目录下，每个数据库作为一个目录存在。每个数据库下，每个数据表作为一个目录存在。我们使用纯文本维护数据表的元信息，由于这些信息很少，所以不使用 `BufPageManager` 维护。

`MetaManager` 直接接受一个 `AstBase*` 作为参数，它判断实例的类型并据此执行不同的操作。

### 内部接口

#### bool createTable(AstCreateTable *ast)

- 将与创建的表的有关的元信息写入文件中。文件路径为 database/DBname/tablename/meta.txt
- 写入前先检验是否工作在某一个数据库下以及该数据库下是否存在同名的表，有则不写入。
- 向meta.txt中写入内容，格式如下：
	- 一个字符串s1，为表名
	- 一个整数M，为表有关内容声明的总数（总列数和主键声明）
	- 一个整数N，为表总列数（包括正常列和外键）
	- N行，每行一个字符串和两个整数，分别表示列名，列的数据类型和本列所占记录空间的大小
	- 接下来M行，表示每个声明，每行格式为：
	    - 一个整数type，表示这个声明是定义正常列，主键或外键
	    - 若为正常列，接下来依次为，字符串name（列名），字符串stype（列的类型，可以是int,float,char,varchar,date），一个字符"T"或"F"（是否必须非空），若为int,char和varchar,还有一个整数len表示其范围
	    - 若为主键声明，接下来依次为，一个整数N1，表示主键的列数，和N1个字符串，表示被当做主键的N1个列的名称。
	    - 若为外键声明，接下来为三个字符串，分别表示，列名，关联的表，关联表的列
- 合法性：要求主键列必须都是该表内除外键外已存在的列，外键关联的表和关联都必须存在，如不合法则删除该文件并返回错误。

#### bool descTable(AstDesc *ast)

- 将元文件的内容输出，格式如下
	- table name ： 表名
	- 接下来M行，为表的有关信息
	- 若为正常列，则为， name type(range) (NOT NULL)
	- 若为主键声明，则为，PRIMARY KEY (colnames)
	- 若为外键声明，则为，FOREIGN KEY colname REFERENCES table ( colname )


#### bool createIndex(AstCreateIndex *ast)

- 将与表相关的索引列信息写入文件中。路径为database/DBname/tablename/index.txt
- index.txt中格式为
	- 两个正整数N，M，分别表示作为索引的列数和下一个新增索引的编号（此索引编号只增不减）
	- 接下来N行，每行一个字符串和一个整数，表示列名和该列对应的索引编号
	- 对于每张表，维护一个只增不减的整数，代表该记录被插入表中的时间戳，作为索引0号
- 如该列原本已是索引，则报错，否则将该列加入索引列表中，更新index.txt中的相关信息

#### 其他接口

均只涉及创建、删除和遍历目录的操作，这部分直接利用 dirent.h 提供的 `DIR` 结构和相关接口，不作赘述。
